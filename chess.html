<html>
	<head>
		<title>Simple Multiplayer 3D Chess</title>
		<style>
			canvas {
				width:100%;
				height:100%;
			}
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script src="threex.domevents.js"></script>
		<script src="useScene.js"></script>
		<script src="useChess.js"></script>
		<script>
			/* Le variabili scene, camera e renderer contengono rispettivamente i tre oggetti necessari a three.js per gestire l'ambiente 3D
			* La variabile domEvents serve a threex.domevents.js per poter agganciare gli eventi agli oggetti 3D
			* raycaster serve a controllare e gestire le collisioni */
			var scene,camera,renderer,domEvents,raycaster;
			// Metto in un array dei vettori necessari al raycaster a rilevare le collisioni
			var rays=[new THREE.Vector3(0, 0, 1),new THREE.Vector3(1, 0, 1),new THREE.Vector3(1, 0, 0),new THREE.Vector3(1, 0, -1),new THREE.Vector3(0, 0, -1),new THREE.Vector3(-1, 0, -1), new THREE.Vector3(-1, 0, 0),new THREE.Vector3(-1, 0, 1)];
			// Queste variabili mi indicano ad ogni richiamo di render() in quale direzione muovere o ruotare la telecamera
			var moveForward=false,moveBackward=false,moveRight=false,moveLeft=false,rotateRight=false,rotateLeft=false,lookRight=false,lookLeft=false,lookAbove=false,lookBelow=false;
			// Queste variabili contengono rispettivamente la scacchiera, le caselle delle mosse ed i pezzi bianchi e neri
			var plane=new Array(8);
			var moves=new Array(8);
			var white=new Array(16);
			var black=new Array(16);
			// actual indica l'ultimo pezzo selezionato, chessboard è la mesh cliccabile nella stanza, turn indica il turno della scacchiera e mode indica in quale scena mi trovo
			var actual,chessboard,turn="e",mode=0;
			// Tengo traccia della posizione della telecamera al cambio di scena
			var rotation=0,positionZ,positionX,angleX,angleY;
			// Due contenitori che contengono gli oggetti delle due scene
			var room=new THREE.Object3D();
			var chess=new THREE.Object3D();
			
			// Avvio il gioco e faccio il render della scena
			init();
			render();
			
			// Questa funzione crea le due scene principali, abbina alcuni eventi e mostra la prima scena
			function init() {
			// Preparo la scena, la telecamera, il renderer ed il gestore di eventi DOM
				scene=new THREE.Scene();
				camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,1000);
				camera.position.set(0,0,5);
				camera.lookAt(scene.position);
				scene.add(camera);
				renderer=new THREE.WebGLRenderer({antialias: true});
				renderer.setSize(window.innerWidth,window.innerHeight);
				document.body.appendChild(renderer.domElement);
				renderer.setClearColorHex(0x777777,1);
			// Dico al renderer di gestire le ombre
				renderer.shadowMapEnabled=true;
				renderer.shadowMapSoft=true;
				document.body.appendChild(renderer.domElement);
			// Preparo il raycaster per gestire le collisioni
				raycaster=new THREE.Raycaster();
				domEvents=new THREEx.DomEvents(camera,renderer.domElement);
			// Creo la prima scena e ci collego un evento che mi consenta di passare alla seconda
				var loader=new THREE.JSONLoader();
				loader.load("Cup.js",function(geometry,materials) {
					chessboard=new THREE.Mesh(geometry,new THREE.MeshFaceMaterial(materials));
					chessboard.scale.set(1,1,1);
					chessboard.position.set(0,0,0);
			// Voglio che l'oggetto generi e riceva ombre
					chessboard.castShadow=true;
					chessboard.receiveShadow=true;
					domEvents.bind(chessboard,"click",function() {  switchScene(); });
					room.add(chessboard);
				});
				scene.add(room);
			// Creo una luce al di sopra della prima scena per generare le ombre
				var light=new THREE.SpotLight(0xffffff,3);
				light.position.set(0,200,200);
				//light.castShadow=true;
				light.shadowDarkness=1;
				light.shadowCameraVisible=true;
				room.add(light);
			// Creo il bordo della schacchiera
				var border=new THREE.Mesh(new THREE.PlaneGeometry(8.5,8.5),new THREE.MeshLambertMaterial({map:THREE.ImageUtils.loadTexture("wood.jpg",{},function() { render(); })}));
				border.position.set(0,-0.01,0);
				border.rotation.x=-90*(Math.PI/180);
				chess.add(border);
			// Creo i quadrati della scacchiera, segnandomi nel name il pezzo che c'è sopra
				var plane_geometry=new THREE.PlaneGeometry(1,1);
				var white_material=new THREE.MeshBasicMaterial({color:"white"});
				var black_material=new THREE.MeshBasicMaterial({color:"black"});
				for(var i=0;i<8;i++) {
					plane[i]=new Array(8);
					for(var j=0;j<8;j++) {
						if((i+j)%2==0)
							plane[i][j]=new THREE.Mesh(plane_geometry,white_material);
						else
							plane[i][j]=new THREE.Mesh(plane_geometry,black_material);
						plane[i][j].position.set(3.5-i,0,3.5-j);
						plane[i][j].rotation.x=-90*(Math.PI/180);
						plane[i][j].name="0";
						chess.add(plane[i][j]);
					}
				}
			// Creo i quadrati delle mosse, gli aggancio l'evento per muoverci i pezzi ma non li mostro, segnandomi nel name se sono attivi o no
				var small_plane_geometry=new THREE.PlaneGeometry(0.9,0.9);
				var red_material=new THREE.MeshBasicMaterial({color:"red"});
				for(var i=0;i<8;i++) {
					moves[i]=new Array(8);
					for(var j=0;j<8;j++) {
						moves[i][j]=new THREE.Mesh(small_plane_geometry,red_material);
						moves[i][j].position.set(3.5-i,0.001,3.5-j);
						moves[i][j].rotation.x=-90*(Math.PI/180);
						moves[i][j].name="0";
						domEvents.bind(moves[i][j],"click",function(event) { moveTo(event.target); });
					}
				}
			// Creo quattro luci ai lati della scacchiera
				var light1=new THREE.DirectionalLight(0xffffff);
				light1.position.set(0,20,25);
				light1.target.position.set(0,0,0);
				chess.add(light1);
				var light2=new THREE.DirectionalLight(0xffffff);
				light2.position.set(0,20,-25);
				light2.target.position.set(0,0,0);
				chess.add(light2);
				var light3=new THREE.DirectionalLight(0xffffff);
				light3.position.set(25,20,0);
				light3.target.position.set(0,0,0);
				chess.add(light3);
				var light4=new THREE.DirectionalLight(0xffffff);
				light4.position.set(-25,20,0);
				light4.target.position.set(0,0,0);
				chess.add(light4);
			// Creo due eventi da tastiera per gestire il cambio di scena e i movimenti della telecamera ed uno per il ridimensionamento della finestra
				window.addEventListener("resize",windowResize);
				window.addEventListener("keydown",function(event) { activateMove(event.keyCode) });
				window.addEventListener("keyup",function(event) { deactivateMove(event.keyCode) });
			}
			// Questa funzione che esegue il render della scena
			function render() {
				requestAnimationFrame(render);
				update();
				renderer.render(scene,camera);
			}
			// Questa funzione reimposta le proporzioni della scena se la finestra viene ridimensionata
			function windowResize() {
				camera.aspect=window.innerWidth/window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth,window.innerHeight);
			}
		</script>
	</body>
</html>